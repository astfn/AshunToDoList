# todoList项目笔记

​	本项目本来是自己简单的练手demo，但是在coding过程中不断的想添加新功能，并且考虑了以后的可扩展性，对组件的封装以及状态的管理，都进行了长时间的思考。

​	由于遇到了自己从未解决过的问题，所以解决时间较长,项目完成耗时(2天半)。

## 难点

​	本来这个应用功能因该特别简单，只完成添加todo，然后点击不同的选项，显示不同状态的数据。但是个人认为：既然是一个应用，怎能只可以添加，不能够删除呢？

​	所以自己想完成一个比较舒适的删除功能，哪么舒适体现在哪里呢？

1. 当进入Admin模式，原来已经完成的todo，依旧被选中
   * 考虑实际因素，80%删除的都是已经完成的选项，不用让用户重新选择
2. 退出Admin模式，并且取消删除时，所有选项的状态回到Admin操作前



## 实现思路

​	

### 数据结构的确认过程

​	之前在做商城项目时，就深深体会到状态管理时 数据的结构 是多么重要，因为数据结构的合理性直接影响到后续的操作，以及业务的扩展性。

以下是state的结构

```
EventStore: {
		//设置部分
    preset: {
      isAdmin: false, //Admin,User
      deleteBufferArr: [],	//管理模式所选元素，(所要删除选项的缓存区)
      //数据排列方式（后续扩展）
      direction: {
        Finish: "firstNotFinish", //firstFinish
        Date: `Increasing` //decreasing
      },
      
    },
    //数据部分
    finish: [],  /*[{id,isFinish,content}]*/
    notFinish: []
  }
```

#### 数据部分

萌生：

​	todolist是一个数据列表，我们可以放在Array中。一开始只是想实现添加简单的文本数据，所以每个元素可以是String，但是为了后续的业务扩展，我选择每个元素为一个Object，这个Object中可以包含以后扩展的所有data。



初始想法：

1. 既然数据的展示是通过三个选项(全部、已完成、未完成)来确定的，那么我就可以将所有数据放在一起，然后点击不同的选项，过滤不同的数据。
2. 根据三个选项，分别存放在一个数据单元中。



后续想法：

1. 首先，我放弃了第一中想法（将所有数据放在一起）
   * 因为考虑到三个选项之间的频繁切换，都要不断的循环过滤符合条件的数据，比较消耗性能
2. 改进第二种想法
   * 由于todo的状态无非两种:`是否完成`，所以我们只需要两个Array（`finish、notfinish`），而不需要存放全部数据的Array
   * 当点击`全部`选项时，只要将两个Array合并返回即可。



#### 设置部分

​	一开始只想新增管理者模式，所以可以扩展一个`mode`选项，但为了后续业务的扩展，我将设置部分定义为一个Object（`preset`），里面可以存储不同的设置选项。

管理者模式

* `isAdmin`判断是否为管理者模式
* `deleteBufferArr`(所要删除选项的缓存区)

后续可能扩展的业务

* `direction` 排列方式
  * `Finish`按完成状态排列
  * `Date`按时间排列



### 效果实现

之前已经介绍过了想要完成的效果

1. 当进入Admin模式，原来已经完成的todo，依旧被选中
2. 退出Admin模式，并且取消删除时，所有选项的状态回到Admin操作前



#### 关键思路

##### 效果2的实现：

**<font color="#e67e22">按钮UI是否与store直接关联</font>**

最开始想法：按钮UI与store直接关联

​	一开始感觉这个效果与购物车非常相似，打算继续沿用之前购物车实现的思路，但在实现的过程中发现了业务的不同。

购物车效果：

* 按钮样式是否活跃，与store中的状态直接关联

* 切换不同的模式，都继续沿用store中的状态，也就说明，Admin模式下改变按钮的选中状态，会直接影响store中的状态，当退出Admin模式时，状态会受到之前操作的影响。



todoList效果：

退出Admin模式，并且取消删除时，所有选项的状态回到Admin操作前。（与之前的购物车效果实现过程产生歧义）

按钮UI不与store直接关联

* 给每个ListItem组件，单独定义一个变量`isSelect`，让其来控制是否为选中状态UI样式的切换
* 当组件created时，让其值与store中的状态保持一致。（UI初始化）
* 当为Admin模式时，改变组件的`isSelect`,但不改变tore中的状态 （为了退出时的状态返回）
* 当退出Admin模式时，让store中的状态赋给`this.isSelect`即可完成效果。
* 当为普通User模式时，改变组件的`isSelect`同时、也要改变tore中的状态，并将数据从原来的Array删除，再添加到对应状态的Array中
  * 比如由选中到未选中状态，就要把该todo从`finish:[]`中删除，再将其添加到`notFinish:[]`中



##### 效果1的实现：

​	要实现效果1，很简单，什么都不做即可，因为基于效果2的实现，当组件created时，已经让其值与store中的状态保持一致。（UI初始化），退出Admin时让store中的状态赋给`this.isSelect`，在此肯定要判断当前的模式，我们只要在else中什么都不做即可。

​	若我们想实现，一进入Admin模式，所有todo都为非选中状态，只要在上述else中，让`this.isSelect=false`即可